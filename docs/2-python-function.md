# 函数

## 什么是函数？

函数在数学上有着清晰的定义，常用的表达形式如下:

$$
y = f(x)
$$

其中x是自变量，y是因变量（返回值），f是对应法则。编程语言中的函数和数学上的函数在本质上是一样的，但也有一些明显的区别。我们先看一下C++中函数的标准定义，

```C++
double sqrt(double x);
```

C++中的函数的参数和返回值都定义了类型，这是和 $y=f(x)$ 最大的区别。数学上的函数处理的都是“**数**”，所以不需要特别指出类型。从这个角度看，编程语言中的函数在形式上其实要比数学上的函数复杂：通过对参数数量、类型，返回值类型的各种排列组合，可以给出丰富和复杂的函数定义。如果我们忽略一个函数的具体实现，

- 函数名
- 输入参数列表 
- 输出/返回值

## 定义函数

在Python中定义函数利用如下语句。
```python
def f():
    pass # 什么也不想做的时候用pass
```
这个函数什么也没做，没有输入也没有输出，调用它不会产生任何效果。但你不要小看它，正所谓**麻雀虽小，五脏俱全**，这个函数包含的内容一点不简单。我们可以用 *dir()* 函数查看任何一个函数的细节：

```python
dir(f)
```

```shell
['__annotations__',
 '__call__',
 '__class__',
 '__closure__',
 '__code__',
 '__defaults__',
 '__delattr__',
 '__dict__',
 '__dir__',
 '__doc__',
 '__eq__',
 '__format__',
 '__ge__',
 '__get__',
 '__getattribute__',
 '__globals__',
 '__gt__',
 '__hash__',
 '__init__',
 '__init_subclass__',
 '__kwdefaults__',
 '__le__',
 '__lt__',
 '__module__',
 '__name__',
 '__ne__',
 '__new__',
 '__qualname__',
 '__reduce__',
 '__reduce_ex__',
 '__repr__',
 '__setattr__',
 '__sizeof__',
 '__str__',
 '__subclasshook__']

```

> dir() 方法像是一个透视镜，是一个非常有用的工具。

一个普通的函数已经自带了这么内容？没有想到吧。在C++中如果你定义了一个如下函数，
```c++
void foo(){}
```
那么它看起来就是一个什么都没有的函数，实际上占用的内存也尽可能小。那么在Python里面为什么会不一样呢？

## 一切皆对象

C++虽然也是面向对象的编程语言，但是远没有其他一些面向对象的编程语言那样极端。在Python里面**一切都是对象**。这句话的意思是：任何变量——包括整数，浮点数，字符串，任何函数，以及任何类都是对象。比如我们同样用dir方法查看一个整数，你会发现它同样包含了很多内容。

```python
a = 1
dir(a)
```

``` 
['__abs__',
 '__add__',
 '__and__',
 '__bool__',
 '__ceil__',
 '__class__',
 '__delattr__',
 '__dir__',
 '__divmod__',
 '__doc__',
 '__eq__',
 '__float__',
 '__floor__',
 '__floordiv__',
 '__format__',
 '__ge__',
 '__getattribute__',
 '__getnewargs__',
 '__gt__',
 '__hash__',
 '__index__',
 '__init__',
 '__init_subclass__',
 '__int__',
 '__invert__',
 'denominator',
 'from_bytes',
 'imag',
 'numerator',
 'real',
 'to_bytes']
```

这些双下划线开头和结尾的方法被成为**魔法方法**，是Python默认为我们创建的。想一想C++中的类，当我们不显示定义构造方法的时候，编译器会帮助我们创建一个默认构造方法。因为在Python中一切皆对象，所以每个对象都有一些编译器帮忙创造的默认方法。 即使是一个什么也不做的函数，或者一个整数变量，都会又丰富的**魔法方法**。


> 在C++中，即使又很多默认方法，但你是看不到他们的，相比之下，他们在Python中更加**可见**。可见性的概念在软件开发中很重要，这一点请在Python中慢慢体会。
> 
关于一切皆对象的概念，请慢慢去体会，它会导致与C++中完全不一样的开发体验。因为一切皆对象的缘故，在Python中你看到的内置类型和C++是有所区别的。比如int类型，在C/C++里面它只占用内存中的四个字节，但是在Python里它还包含了对象头：

![20220213175357](http://haipeng-openwrite.oss-cn-beijing.aliyuncs.com/images%5C8e02f92647b2343c12df4f2142fb6a12.png)

## 魔法方法

魔法方法通常都会被编译器自动调用，并且不同对象的默认魔法方法是不同的，上述函数和整数变量的魔法方法就有很多不同。我们以 __add__ 这一魔法方法为例，看一下它的用途：

```python
a = 1
a + 2 # 实际上调用了 __add__ 魔法方法
```

不过，Python并没有阻止我们手动去调用这些方法：

```python
a = 1
a.__add__(2) # 你会得到 3
```

了解这点之后，你就可以自己给任何一个对象定义__add__方法，在C++里，相当于你重载了 + 这个运算符。这一道理对其他任何魔法方法都适用，Python中的魔法方法实在是有点多，在此就不一一列举他们的作用了，需要了解的时候请尽情google之。


## 函数参数

了解完魔法方法之后，我们开始定义一些真正有用的函数，并研究一下它的性质。

```python
def print3(a,b,c):
    print(a,b,c)
```
这个函数只负责打印三个输入变量。这里我们并没有定义三个输入参数的类型，因为Python是动态类型语言，会在运行时去判别变量的类型，不需要在定义的时候显示指定。这给开发带来了很多灵活性。

### 位置参数和key-value参数

在调用任何一个方法或函数时，都可以有以下三种方式来传递参数:

```python
print3(1,2,3)
print3(a = 1,c = 3, b=2)
print3(1,c = 3, b=2)

# 1 2 3
# 1 2 3
# 1 2 3
```
1. 首先，我们可以按位置传入每个参数，这和C++并没有什么不同。
2. 其次，我们也可以按照参数名和值的键值对方式传入参数，当你指定参数名的时候，顺序就变得不重要了。
3. 混合使用两种方式传入参数：前面是按照位置传入，后面按照key-value的形式传入。

那么，是不是可以随便混用呢？试一试：

```python
print3(1,b = 2, 3)
```
```shell
  File "C:\Users\haipw\AppData\Local\Temp/ipykernel_47416/3420492099.py", line 1
    f(1,b = 2, 3)
                ^
SyntaxError: positional argument follows keyword argument
```

仔细阅读错误提示，它已经告诉你答案：**SyntaxError: positional argument follows keyword argument.** ，Python不允许这样做。

### 可变数目参数

以上方法已经够灵活了，但是程序员的需求是无止境的，有时候我们还想更灵活一些。上面定义的函数，只能接受三个参数，如果我们想随便给一个函数传入任意数量的参数呢？（有点太随意了，但Python可以满足你）:

```python
def f(a,b,c, *args, **kwargs):
    print(a,b,c)
    print("args:")
    for k in args:
        print(k)
    print("kwargs:")
    for k,v in kwargs.items():
        print(k,v)
        
f(1,2,3,4,5,6,x=1,y=4)

# 1 2 3
# args:
# 4
# 5
# 6
# kwargs:
# x 1
# y 4
```

\*args 把所有未知的 positional arguments收集到一个列表里面，\*\*kwargs把所有未知的keyword arguments收集到一个字典里面。星号在这里可以理解为 **收集** 或者 **打包压缩**。

## 函数的返回值

在c++里面，函数只能有一个返回值，如果你想返回多个值，它们必须被包含在一个对象里面。在Python里也是如此，但看起来略有不同：

```python
def foo(x):
    return x, 2*x, 3*x
```

好像我们可以返回多个值啊？打印一个试试：

```python
print(foo(1))
# (1, 2, 3)
```

从输出的结果看，我们得到的其实是一个元组（注意他们是被括号包裹起来的，是元组的形式）。所以虽然看起来你返回来多个结果，但是Python又偷偷做了一层处理，返回的还是一个。最终，你可以直接用一个元组变量去接收这个返回值，也可以利用**多元赋值**的性质，直接把元组赋值给三个变量。

```python
x = foo(1)
x1, x2, x3 = foo(1)
```

第二种写法，看起来和你返回了多个结果没什么区别。试想一下，如果让你写一个函数返回一个整数，一个数组和一个字符串，在C++里面你会怎么实现？而在Python里面，你甚至都不用想去如何实现，直接返回就是了。

## 类型注解和静态代码分析

函数的参数和返回值也是动态类型，这虽然很灵活，但是也会带来很多问题，让一些隐藏的bug不容易被发现。

```python
def foo(a:int, b:str, c:list) -> dict:
    return {}
```

linter 静态代码分析工具。可以帮助你检查潜在的错误。这样你可以在运行之前发现问题，而不是在代码上线之后才发现一堆bug~。


## 函数编程



### 函数作为变量

lambda 表达式

### 迭代器

### 生成器

:link:[生成器](https://www.cnblogs.com/liangmingshen/p/9706181.html)



### 递归

支持递归是编程语言的基本要求，Python自然也不例外。我们尝试用递归计算斐波那契数列的第n项：

```python

def fib(n):
    if n < 1:
        return None
    if n == 1:
        return 1
    elif n == 2:
        return 1
    else:
        return fib(n-1) + fib(n-2)

print(fib(10))

# output：
# 55

```

### 函数作为参数

函数作为参数最典型的例子就是排序。如果你有一个列表，你想对它按照自己定义的方式排序。

```python
sort
```

map

reduce

### 函数作为返回值

### 闭包
